# 概述

欢迎来到这个模拟器！这个模拟器的目的是通过观察线程如何交替执行来帮助你熟悉线程的工作原理；模拟器 `x86.py` 将帮助你理解这一点。

该模拟器模拟了多个线程执行简短汇编序列的过程。需要注意的是，操作系统代码（例如执行上下文切换的代码）**没有**显示；因此，你看到的只是用户代码的交替执行。

运行的汇编代码基于 x86 架构，但有所简化。在此指令集里，有四个通用寄存器（%ax、%bx、%cx、%dx）、一个程序计数器（PC）以及一小部分足以完成任务的指令。

以下是我们将能够运行的示例代码片段：

```sh
.main
mov 2000, %ax   # 获取地址 2000 处的值
add $1, %ax     # 将值加 1
mov %ax, 2000   # 将更新后的值存回地址 2000
halt
```

这段代码很容易理解。第一条指令 `mov`（x86 指令）从地址 2000 获取一个值，并将其加载到寄存器 %ax 中。在这个简化版本的 x86 指令集中，地址的表示方式可以是以下几种：

- `2000` : 数字（2000）表示地址
- `(%cx)` : 寄存器的内容（括号内的内容）表示地址
- `1000(%dx)` : 数字加上寄存器的内容表示地址
- `10(%ax,%bx)` : 数字加上寄存器 1 和寄存器 2 的内容表示地址

要存储一个值，可以使用相同的 `mov` 指令，但这次需要交换参数的位置，例如：

```sh
mov %ax, 2000
```

指令 `add` 也很简单：它将一个立即数值（由 `$1` 指定）加到第二个参数指定的寄存器中（即 `%ax = %ax + 1`）。

因此，我们可以理解上面代码的执行过程：它首先从地址 2000 加载值，增加 1，然后将更新后的值存回地址 2000。

伪指令 `halt` 只是停止当前线程的运行。

接下来，我们来运行模拟器，看看这如何工作！假设上述代码存储在文件 `simple-race.s` 中。

```sh
prompt> ./x86.py -p simple-race.s -t 1

       线程 0
1000 mov 2000, %ax
1001 add $1, %ax
1002 mov %ax, 2000
1003 halt

prompt>
```

这里使用的参数指定了程序（`-p`）、线程数量（`-t 1`）以及中断频率——这决定了调度程序会以多长时间间隔被唤醒并切换任务。因为这个例子中只有一个线程，所以中断频率不重要。

输出内容很容易理解：模拟器打印出程序计数器（从 1000 到 1003）和当前执行的指令。需要注意的是，我们假设（不现实地）所有指令只占用一个字节的内存；在 x86 中，指令的大小是可变的，通常占用一个字节或更多字节。

我们可以使用更详细的跟踪来更好地理解执行过程中机器状态是如何变化的：

```sh
prompt> ./x86.py -p simple-race.s -t 1 -M 2000 -R ax,bx

 2000      ax    bx          线程 0
    ?       ?     ?
    ?       ?     ?   1000 mov 2000, %ax
    ?       ?     ?   1001 add $1, %ax
    ?       ?     ?   1002 mov %ax, 2000
    ?       ?     ?   1003 halt

哎呀！忘记了 `-c` 参数（它会帮你计算出答案）。

prompt> ./x86.py -p simple-race.s -t 1 -M 2000 -R ax,bx -c

 2000      ax    bx          线程 0
    0       0     0
    0       0     0   1000 mov 2000, %ax
    0       0     0   1001 add $1, %ax
    1       1     0   1002 mov %ax, 2000
    1       1     0   1003 halt
```

通过使用 `-M` 参数，我们可以跟踪内存位置（逗号分隔的列表可以跟踪多个地址，例如 `2000,3000`）；使用 `-R` 参数可以跟踪特定寄存器的值。

左侧的值显示的是右侧指令执行后的内存/寄存器内容。例如，执行 `add` 指令后，你可以看到 %ax 的值已经增加到 1；执行第二条 `mov` 指令（PC=1002）后，可以看到地址 2000 的内存内容也增加了。

接下来，我们将学习一些其他的指令。以下是一个包含循环的代码片段：

```sh
.main
.top
sub  $1,%dx
test $0,%dx     
jgte .top         
halt
```

这里引入了一些新内容。首先是 `test` 指令。此指令有两个参数并进行比较，然后设置隐式的“条件码”（类似于一位寄存器），后续指令可以依赖这些条件码。

在这种情况下，另一个新指令是 `jump` 指令（例如 `jgte`，即“如果大于或等于则跳转”）。此指令会在第二个值大于或等于第一个值时跳转。

最后要注意的是，为了使这段代码正常工作，`dx` 必须初始化为 1 或更大的值。

因此，我们运行这个程序如下：

```sh
prompt> ./x86.py -p loop.s -t 1 -a dx=3 -R dx -C -c

   dx   >= >  <= <  != ==        线程 0
    3   0  0  0  0  0  0
    2   0  0  0  0  0  0  1000 sub  $1,%dx
    2   1  1  0  0  1  0  1001 test $0,%dx
    2   1  1  0  0  1  0  1002 jgte .top
    1   1  1  0  0  1  0  1000 sub  $1,%dx
    1   1  1  0  0  1  0  1001 test $0,%dx
    1   1  1  0  0  1  0  1002 jgte .top
    0   1  1  0  0  1  0  1000 sub  $1,%dx
    0   1  0  1  0  0  1  1001 test $0,%dx
    0   1  0  1  0  0  1  1002 jgte .top
   -1   1  0  1  0  0  1  1000 sub  $1,%dx
   -1   0  0  1  1  1  0  1001 test $0,%dx
   -1   0  0  1  1  1  0  1002 jgte .top
   -1   0  0  1  1  1  0  1003 halt
```

`-R dx` 参数跟踪 %dx 寄存器的值；`-C` 参数跟踪 `test` 指令设置的条件码。最后，`-a dx=3` 参数将 `%dx` 寄存器初始化为 3。

从跟踪中可以看到，`sub` 指令逐渐减小 %dx 的值。前几次调用 `test` 时，只有 “>=” “>” 和 “!=” 条件被设置。然而，最后一次 `test` 找到 %dx 和 0 相等，因此随后的跳转没有发生，程序最终停止。

接下来，我们进入一个更有趣的例子，即多线程的竞争条件。首先看看代码：

```sh
.main
.top
# 临界区
mov 2000, %ax       # 获取地址 2000 处的值
add $1, %ax         # 将值加 1
mov %ax, 2000       # 存回值

# 看是否继续执行循环
sub  $1, %bx
test $0, %bx
jgt .top

halt
```

这段代码有一个临界区，其中它从地址 2000 加载一个变量的值，给这个值加 1，然后再存回去。

随后的代码会将循环计数器（在 `%bx` 中）递减，测试它是否大于等于零，如果是，则跳回到临界区继续执行。

```sh
prompt> ./x86.py -p looping-race-nolock.s -t 2 -a bx=1 -M 2000 -c

 2000      bx          线程 0                线程 1
    0       1
    0       1   1000 mov 2000, %ax
    0       1   1001 add $1, %ax
    1       1   1002 mov %ax, 2000
    1       0   1003 sub  $1, %bx
    1       0   1004 test $0, %bx
    1       0   1005 jgt .top
    1       0   1006 halt
    1       1   ----- Halt;Switch -----  ----- Halt;Switch -----
    1       1                            1000 mov 2000, %ax
    1       1                            1001 add $1, %ax
    2       1                            1002 mov %ax, 2000
    2       0                            1003 sub  $1, %bx
    2       0                            1004 test $0, %bx
    2       0                            1005 jgt .top
    2       0                            1006 halt
```

在这个例子中，你可以看到每个线程运行了一次，并且每个线程都更新了共享变量（地址 2000），因此导致该地址的值变成了 2。

`Halt;Switch` 行会出现在每次线程停止并且调度程序需要切换到另一个线程时。

接下来，我们使用较小的中断频率来运行相同的程序。以下是运行的结果：

```sh
prompt> ./x86.py -p looping-race-nolock.s -t 2 -a bx=1 -M 2000 -i 2

 2000          线程 0                线程 1
    ?
    ?   1000 mov 2000, %ax
    ?   1001 add $1, %ax
    ?   ------ 中断 ------  ------ 中断 ------
    ?                            1000 mov 2000, %ax
    ?                            1001 add $1, %ax
    ?   ------ 中断 ------  ------ 中断 ------
    ?   1002 mov %ax, 2000
    ?   1003 sub  $1, %bx
    ?   ------ 中断 ------  ------ 中断 ------
    ?                            1002 mov %ax, 2000
    ?                            1003 sub  $1, %bx
    ?   ------ 中断 ------  ------ 中断 ------
    ?   1004 test $0, %bx
    ?   1005 jgt .top
    ?   ------ 中断 ------  ------ 中断 ------
    ?                            1004 test $0, %bx
    ?                            1005 jgt .top
    ?   ------ 中断 ------  ------ 中断 ------
    ?   1006 halt
    ?   ----- Halt;Switch -----  ----- Halt;Switch -----
    ?                            1006 halt
```

如你所见，每个线程在运行 2 条指令后都会被中断一次，这是通过 `-i 2` 参数指定的。你可以看到两线程交替运行，并且每个线程都执行了自己的临界区代码。

### 关于内存[2000]的值
在这种情况下，由于线程交替执行，内存地址 2000 的值会在不同线程之间进行更新。如果每个线程都正确地执行了加法操作并将值存回去，那么在程序结束时，地址 2000 的值应为 2。

然而，由于没有加锁机制来防止线程间的干扰，因此可能发生竞态条件，导致内存地址 2000 的值并不一定是 2。这取决于线程执行的顺序和中断频率。

### 更复杂的模拟
模拟器可以处理多种情况，包括更复杂的竞态条件。你可以通过更改线程数量、添加中断、改变中断频率等方式，创建不同的程序并模拟并发执行。具体来说，模拟器提供了以下功能选项：

- `-s` 设置随机种子。
- `-t` 设置线程数量。
- `-p` 设置源程序文件。
- `-i` 设置中断频率。
- `-r` 启用随机中断。
- `-a` 为每个线程指定寄存器初始值。
- `-L` 设置加载程序的地址。
- `-m` 设置内存大小（KB）。
- `-M` 设置跟踪的内存地址。
- `-R` 设置跟踪的寄存器。
- `-C` 启用条件码追踪。
- `-S` 输出额外的统计信息。
- `-c` 自动计算答案。

通过这些选项，你可以创建非常复杂的多线程程序并探索并发中的问题，如竞态条件、死锁等。

希望这些示例能帮助你更好地理解并发编程的基本概念以及如何利用模拟器模拟多线程行为。