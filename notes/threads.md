# thread

## new knowledge

### volatile 

告诉编译器某个变量的值可能会在程序执行过程中发生变化，而不通过当前程序的控制流（例如，可能由硬件或其他线程修改）。

通过使用 volatile，编译器会**避免对该变量进行优化**，从而确保程序每次访问该变量时`都会从内存中重新读取它`，而不是使用缓存或寄存器中的值。

### 反汇编程序（objdump(linux)）

```bash
objdump -d obj           # 其中obj为可执行文件
```

这段代码是一个汇编代码的反汇编结果，展示了一个 ELF 格式的 64 位 x86-64 程序的各个部分，具体包括 `.init`、`.plt`、`.text` 等段的内容。以下是对一些主要部分的解释：

- `.init` 部分：
    - **0x1000 <_init>**: 这是程序初始化部分的开始。`endbr64` 是一个新的指令，用于启用控制流保护（Control Flow Integrity, CFI）。接下来有一些栈操作，如调整 `%rsp`，并且检查是否需要调用 `__gmon_start__`。如果存在它，则调用该函数。
    - `sub $0x8, %rsp` 和 `add $0x8, %rsp` 是栈指针的调整，通常用于保存和恢复栈空间。
    - 最后通过 `ret` 返回，完成初始化。

- `.plt` 部分：
`.plt` 是 "Procedure Linkage Table" 的缩写，是一种处理函数调用的机制，特别是在动态链接的情况下。它通过间接调用动态库中的函数，通常用于实现共享库中的函数调用。

    - 例如，`puts@plt` 和 `printf@plt` 都是动态链接的库函数，它们会通过跳转到一个表项来调用相应的库函数。

    这些跳转的指令通常是：
    ```assembly
    f2 ff 25 <address>  bnd jmp *<address>
    ```
    这种指令会根据偏移量跳转到全局偏移表（GOT）中的对应地址。

- `.text` 部分：
`.text` 部分是实际的程序代码所在部分。这段代码包含程序的执行逻辑，比如 `main` 函数、线程创建和加入等。

##  