# 虚拟化(virtualizatioin)

## 概念

操作系统将物理资源(CPU, disk, memory) 转化为**更通用, 更强大, 更易于使用**的虚拟形式, 所以有时也将操作系统称为**虚拟机**

- 虚拟化CPU:

  在硬件的帮助下, OS负责提供家乡(illusion), 即系统拥有非常多虚拟CPU的假象, 将单个CPU(或者其中的一部分)转换为看似无限数量的CPU, 从而让许多程序看似同时运行

- 虚拟化内存:

  **内存就是一个字节数组**, 进行读写时必须指定地址, 虚拟化内存就是值每个进程访问自己的私有**虚拟地址空间**, 并映射到机器的物理内存

## 进程

进程就是运行中的程序, 操作系统为**正在运行的程序提供的抽象**就是进程(process)

### 机器状态

组成:

- 内存: 包含正在运行的程序和写入的数据, 所以进程可以访问的内存(即地址空间)也是该进程的一部分
- 寄存器: 指令明确的读取,更新寄存器. 一些特殊的寄存器(如PC, SP, FP(frame pointer))构成了机器状态的一部分



### 进程API

- 创建
- 销毁
- 等待
- 其他控制
- 状态

系统调用:

- [fork()系统调用](../my_code/chap5/fork_5_1.c)

- [wait()系统调用](../my_code/chap5/wait.c)

- [exec()系统调用](../my_code/chap5/exec.c) 

  让子进程父进程执行不同的程序, exec()从可执行程序中加载代码和静态数据 ,并用它覆盖自己的代码段(所以并没有创建新进程, 而是直接将当前的运行程序替换为不同的运行程序(`wc`, 也是一个程序, 使用`wc --help`查看更多), 所以子进程执行完毕后, 对exec的成功调用永远不会返回

> 上述系统与`shell`的关系:
>
> shell也是一个用户程序, 首先显示一个提示符(prompt), 后等待用户输入, shell可以在文件系统中找到可执行程序, 调用`fork()`创建新进程, 调用`exec()`的某个变体来执行这个可执行程序, 调用`wait()`等待该命令的完成. 子进程结束, shell从`wait()`返回并再次输出一个提示符, 等待用户的下一条输入

还有一点: **RTFM**(read the man)

ubuntu使用`man man`指令就可以查看, 网络上也有

### 创建过程

- 将代码和所有静态数据load到内存(更准确的是进程的地址空间)中
- 为程序的运行时栈(stack)分配内存----c中使用stack分配局部变量, 函数参数及返回地址,OS分配这些内存并提供给进程(也可能用参数初始化栈, 将参数填入main)
- 为程序的堆(heap)分配内存----c中的heap用于分配显示请求的内存



### 状态

- 运行
- 就绪(OS由于某种原因不在此时运行)
- 阻塞(I/O请求)

## 虚拟化CPU

**时分共享**CPU实现

### 受限直接执行(limited direct execution	LDE)

#### 关键问题1: 如何执行受限的操作 ----- 使用受保护的控制权转移

硬件通过提供不同的执行模式来协助操作系统:

- 用户模式: 应用程序不能完全访问硬件资源, 例如进程不能发出I/O请求

  - ps: 管理员模式只是较高LEVEL的用户模式

- 内核模式: OS可以访问机器的全部资源, 是操作系统内核的运行方式

  要执行系统调用, 程序必须执行特殊的**陷阱(trap)**指令, 该指令同时跳入内核并升级权限级别为内核模式, 执行完后系统调用`return-from-trap`指令, 回到发起调用的用户程序中, 同时降低权限

  > 有关I/O的代码(如C中的`open(), read()`), 无法在用户态执行, 而是OS执行, 当执行代码时发现自己是用户态, 会立即发出**软中断**, 跳转到内核处理程序, 此时即为"陷入内核态", C中的系统调用部分使用汇编语言实现的, 支持了陷入OS

  执行陷阱也需要保护现场的步骤, 例如:x86处理器会将PC, 标志寄存器等推送到每个进程的**内核栈**, 从陷阱返回时会弹出这些值

#### 两个阶段

- 系统引导阶段: 内核初始化陷阱表, 方便CPU日后定位, 此时为内核特权
- 运行程序阶段: 陷阱返回指令之前内核设置分配内存等操作, 后将CPU切换到用户模式, 当运行进程希望发出系统调用时, 重新陷入OS. 整个进程执行完毕后从入口点(如`main()`函数)
- 最后, 回到内核, 释放进程中的内存, 将进程从进程列表中清除

#### 关键问题2: 进程间的切换 ------- OS如何重获CPU的控制权

- 协作方式: 等待系统调用

  OS通过等待系统调用或者非法操作(如除以0, 导致访问无法访问的内存, 就会陷入), 这样会有无限循环的风险

- 非协作方式: OS控制

  > 关键问题3 如何在没有协作的情况获得控制权

  使用**时钟中断**

- 保存和恢复上下文

  OS为当前正在执行的进程保存一些寄存器的值(到他的内核态), 并为即将执行的进程(从它的内核态)恢复寄存器的值, 这样确保了最后执行的返回陷阱指令可以继续执行另一个进程

  此协议的两种寄存器保护:

  - 时钟中断: 由硬件隐式保护
  - OS决定进程间的切换, 是显示的保存







